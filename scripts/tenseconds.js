// Generated by CoffeeScript 1.6.3
(function() {
  this.GameLayer = cc.Layer.extend({
    init: function(mapKlass) {
      this._super();
      this.mapKlass = mapKlass;
      this.map = mapKlass.create();
      this.addChild(this.map);
      this.player = Player.create(this, this.map);
      this.addChild(this.player);
      this.timeGauge = TimeGauge.create(this);
      this.addChild(this.timeGauge);
      this.itemBar = ItemBar.create(this, this.map.getInventory());
      this.addChild(this.itemBar);
      this.createLabel();
      this.schedule(this.update);
      this.isRunning = false;
      this.beginCountdown();
      this.setTouchEnabled(true);
      return true;
    },
    createLabel: function() {
      var screenSize;
      screenSize = cc.Director.getInstance().getWinSize();
      this.label = cc.LabelTTF.create("3", "Times New Roman", 64, cc.c3b(255, 0, 0));
      this.label.setPosition(cc.p(screenSize.width / 2, screenSize.height * 3 / 4));
      this.label.setVisible(false);
      return this.addChild(this.label);
    },
    beginCountdown: function() {
      var action, start, wait;
      wait = cc.DelayTime.create(1);
      start = cc.CallFunc.create((function() {
        return this.startLevel();
      }), this);
      action = cc.Sequence.create([
        cc.CallFunc.create((function() {
          return this.displayMessage("3");
        }), this), wait.copy(), cc.CallFunc.create((function() {
          return this.displayMessage("2");
        }), this), wait.copy(), cc.CallFunc.create((function() {
          return this.displayMessage("1");
        }), this), wait.copy(), cc.CallFunc.create((function() {
          return this.displayMessage("Go");
        }), this), wait.copy(), cc.CallFunc.create((function() {
          return this.displayMessage(void 0);
        }), this), start
      ]);
      return this.runAction(action);
    },
    displayMessage: function(text) {
      if (text) {
        this.label.setVisible(true);
        return this.label.setString(text);
      } else {
        return this.label.setVisible(false);
      }
    },
    startLevel: function() {
      this.isRunning = true;
      return this.player.moveForward();
    },
    levelComplete: function() {
      var action, progessToNextLevel, wait;
      this.isRunning = false;
      wait = cc.DelayTime.create(2);
      progessToNextLevel = cc.CallFunc.create((function() {
        return this.nextLevel();
      }), this);
      action = cc.Sequence.create([
        cc.CallFunc.create((function() {
          return this.displayMessage("Stage Complete");
        }), this), wait, progessToNextLevel
      ]);
      return this.runAction(action);
    },
    retryLevel: function() {
      return cc.Director.getInstance().replaceScene(TenSecondsScene.create(this.mapKlass));
    },
    nextLevel: function() {
      return cc.Director.getInstance().replaceScene(TenSecondsScene.create(this.map.getNextLevel()));
    },
    update: function(dt) {
      if (this.isRunning) {
        return this.timeGauge.update(dt);
      }
    },
    timeEllapsed: function() {
      var action, retryCurrentLevel, wait;
      this.player.stopAllActions();
      this.isRunning = false;
      wait = cc.DelayTime.create(2);
      retryCurrentLevel = cc.CallFunc.create((function() {
        return this.retryLevel();
      }), this);
      action = cc.Sequence.create([
        cc.CallFunc.create((function() {
          return this.displayMessage("Time Over");
        }), this), wait, retryCurrentLevel
      ]);
      return this.runAction(action);
    },
    createLevel: function(levelName) {
      return true;
    },
    menuCloseCallback: function(sender) {
      return true;
    },
    addItem: function(x, y, type, description) {
      return this.map.addItem(x, y, type, description);
    },
    setCurrentInventory: function(inventory) {
      return this.currentInventory = inventory;
    },
    onTouchesBegan: function(touches, events) {
      var tap, touch, x, y;
      if (touches && this.isRunning && this.currentInventory) {
        touch = touches[0];
        tap = touch.getLocation();
        x = Math.floor(tap.x / 64);
        y = Math.floor(tap.y / 64);
        touch = touches[0];
        tap = touch.getLocation();
        this.currentInventory.useAtLocation(x, y);
      }
      return true;
    },
    onTouchesMoved: function(touches, event) {
      return true;
    },
    onTouchesEnded: function(touches, event) {
      return true;
    },
    onTouchesCancelled: function(touches, event) {
      return true;
    }
  });

  this.TenSecondsScene = cc.Scene.extend({
    init: function(mapKlass) {
      this._super();
      return this.mapKlass = mapKlass;
    },
    onEnter: function() {
      var layer;
      this._super();
      layer = new GameLayer();
      layer.init(this.mapKlass);
      return this.addChild(layer);
    }
  });

  TenSecondsScene.create = function(mapKlass) {
    var scene;
    scene = new TenSecondsScene();
    scene.init(mapKlass);
    return scene;
  };

}).call(this);
